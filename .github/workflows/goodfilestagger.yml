name: Good file Check and Tag Semantic Version

on:
  push:
    branches:
      - develop

jobs:
  tag-commit:
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/heads/develop')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Check for modified files
        id: check_changes
        run: |
          git fetch --prune --unshallow
          
          # Get the previous commit on the current branch
          BASE_COMMIT=$(git rev-parse HEAD^)
          echo "Base commit: $BASE_COMMIT"
          
          # Get the current commit
          CURRENT_COMMIT=${{ github.sha }}
          echo "Current commit: $CURRENT_COMMIT"

          # Get the list of modified files
          MODIFIED_FILES=$(git diff --name-only $BASE_COMMIT $CURRENT_COMMIT)
          echo "Modified files: $MODIFIED_FILES"
          echo "MODIFIED_FILES=$MODIFIED_FILES" >> $GITHUB_ENV

          # Define folders/files to watch
          WATCHED="UnityProject/Packages/ UnityProject/ProjectSettings/ UnityProject/Assets/Plugins/ UnityProject/Assets/Scripts/Core/SecureStuff/"

          TRIGGERED=false
          for ITEM in $WATCHED; do
            for MOD_FILE in $MODIFIED_FILES; do
              if [[ "$MOD_FILE" == $ITEM* ]]; then
                echo "Found changes in $ITEM"
                TRIGGERED=true
                break
              fi
            done
            if [ "$TRIGGERED" == true ]; then
              break
            fi
          done
          
          if [ "$TRIGGERED" == true ]; then
            echo "TRIGGERED=true" >> $GITHUB_ENV
          else
            echo "TRIGGERED=false" >> $GITHUB_ENV
          fi

      - name: Increment version and create tag
        if: env.TRIGGERED == 'true'  # Only run if files were modified
        id: version_bump
        run: |
          # Get the latest tag, sorted by version
          LATEST_TAG=$(git tag --sort=-v:refname | grep -m 1 "^good file" || true)

          if [ -z "$LATEST_TAG" ]; then
            # No tags found, start with version 0.1.0
            MAJOR=0
            MINOR=1
            PATCH=0
          else
            # Remove "good file " prefix and split into version components
            VERSION=${LATEST_TAG#"good file "}
            MAJOR=$(echo "$VERSION" | cut -d. -f1)
            MINOR=$(echo "$VERSION" | cut -d. -f2)
            PATCH=$(echo "$VERSION" | cut -d. -f3)
            # Increment the minor version
            MINOR=$((MINOR + 1))
            PATCH=0  # Reset patch to 0 when incrementing the minor version
          fi

          # Construct the new version
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          NEW_TAG="good file $NEW_VERSION"
          echo "New version: $NEW_TAG"
          echo "NEW_VERSION=$NEW_TAG" >> $GITHUB_ENV

      - name: Tag the commit
        if: env.TRIGGERED == 'true'  # Only tag if files were modified
        run: |
          NEW_VERSION=${{ env.NEW_VERSION }}
          # Create and push the new tag
          git tag "$NEW_VERSION"
          git push origin "$NEW_VERSION"