name: Good file Check and Tag Semantic Version

on:
  pull_request:
    types:
      - opened
      - synchronize
      - reopened
      - edited
  push:
    branches:
      - develop
jobs:
  tag-commit:
    if: github.event_name == 'push' && startsWith(github.ref, 'refs/heads/develop')
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v3

      - name: Check for modified files
        id: check_changes
        run: |
          git fetch --prune --unshallow
          MODIFIED_FILES=$(git diff --name-only ${{ github.event.pull_request.base.sha }} ${{ github.sha }})
          echo "Modified files: $MODIFIED_FILES"
          echo "::set-output name=modified::$MODIFIED_FILES"

          # Define folders/files to watch
          WATCHED="UnityProject/Packages/ UnityProject/ProjectSettings/ UnityProject/Assets/Plugins/ UnityProject/Assets/Scripts/Core/SecureStuff/"
          
          # Check if any of the watched files/folders were modified
          for ITEM in $WATCHED; do
            if echo "$MODIFIED_FILES" | grep -q "^$ITEM"; then
              echo "Found changes in $ITEM"
              echo "::set-output name=triggered::true"
              exit 0
            fi
          done

          # If no watched files were modified, do not trigger version increment
          echo "::set-output name=triggered::false"

      - name: Increment version and create tag
        if: steps.check_changes.outputs.triggered == 'true'  # Only run if files were modified
        id: version_bump
        run: |
          # Get the latest tag, sorted by version
          LATEST_TAG=$(git tag --sort=-v:refname | grep -m 1 "^good file" || true)
          
          if [ -z "$LATEST_TAG" ]; then
            # No tags found, start with version 0.1.0
            MAJOR=0
            MINOR=1
            PATCH=0
          else
            # Remove "good file " prefix and split into version components
            VERSION=${LATEST_TAG#"good file "}
            MAJOR=$(echo "$VERSION" | cut -d. -f1)
            MINOR=$(echo "$VERSION" | cut -d. -f2)
            PATCH=$(echo "$VERSION" | cut -d. -f3)

            # Increment the minor version
            MINOR=$((MINOR + 1))
            PATCH=0  # Reset patch to 0 when incrementing the minor version
          fi

          # Construct the new version
          NEW_VERSION="$MAJOR.$MINOR.$PATCH"
          NEW_TAG="good file $NEW_VERSION"

          echo "New version: $NEW_TAG"
          echo "::set-output name=new_version::$NEW_TAG"

      - name: Tag the commit
        if: steps.check_changes.outputs.triggered == 'true'  # Only tag if files were modified
        run: |
          NEW_VERSION=${{ steps.version_bump.outputs.new_version }}
          # Create and push the new tag
          git tag "$NEW_VERSION"
          git push origin "$NEW_VERSION"